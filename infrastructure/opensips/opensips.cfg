#
# OpenSIPS Configuration for AI Voice Connector
# Banking IVR Voice Assistant System
#

####### Global Parameters #########

# Log configuration
log_level=3
log_stderror=no
log_facility=LOG_LOCAL0
log_name="opensips"

# Process and memory settings
children=4
auto_aliases=no

# Network settings
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060

# AI Voice Connector backend endpoint
define AI_BACKEND_HOST "ai-voice-connector"
define AI_BACKEND_PORT 50051

####### Modules Section ########

# Core modules
loadmodule "db_postgres.so"
loadmodule "signaling.so" 
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "sipmsgops.so"
loadmodule "mi_datagram.so"
loadmodule "mi_fifo.so"
loadmodule "proto_udp.so"
loadmodule "proto_tcp.so"

# Media and dialog modules
loadmodule "dialog.so"
loadmodule "rtpproxy.so" 
loadmodule "nathelper.so"
loadmodule "mediaproxy.so"

# AI integration modules
loadmodule "rest_client.so"
loadmodule "json.so"
loadmodule "event_datagram.so"

####### Module Parameters #######

# MI Datagram (Management Interface)
modparam("mi_datagram", "socket_name", "udp:0.0.0.0:8087")
modparam("mi_datagram", "socket_timeout", 2000)

# Event Datagram (Event notifications)
modparam("event_datagram", "socket_name", "udp:0.0.0.0:8090")

# Database connection
modparam("usrloc", "db_mode", 0)

# Dialog module
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "timeout_avp", "$avp(timeout)")
modparam("dialog", "default_timeout", 21600)  # 6 hours
modparam("dialog", "profiles_with_value", "caller")

# Record routing
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# Transaction module
modparam("tm", "fr_timer", 5)
modparam("tm", "fr_inv_timer", 30)
modparam("tm", "wt_timer", 5)
modparam("tm", "delete_timer", 2)
modparam("tm", "T1_timer", 500)
modparam("tm", "T2_timer", 4000)

# REST client for AI backend communication
modparam("rest_client", "connection_timeout", 300)
modparam("rest_client", "max_async_transfers", 100)
modparam("rest_client", "ssl_verifypeer", 0)

####### Routing Logic ########

# Main routing logic
route {
    
    # Initial sanity checks
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    if (msg:len >= 2048) {
        sl_send_reply(513, "Message too big");
        exit;
    }

    # Handle retransmissions
    if (has_totag()) {
        if (loose_route()) {
            if (is_method("BYE")) {
                # Handle call termination
                route(AI_CALL_END);
                # Continue with normal processing
            }
            route(RELAY);
        } else {
            if (is_method("ACK")) {
                if (t_check_trans()) {
                    route(RELAY);
                } else {
                    exit;
                }
            }
            sl_send_reply(404, "Not here");
        }
        exit;
    }

    # Record routing for all requests
    record_route();

    # Handle different request types
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(AI_CALL_END);
            route(RELAY);
        }
        exit;
    }

    # Route REGISTER requests
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Route INVITE requests to AI backend
    if (is_method("INVITE")) {
        route(AI_CALL_START);
        exit;
    }

    # Handle other methods
    route(RELAY);
}

# AI Call Start Route
route[AI_CALL_START] {
    xlog("L_INFO", "AI_CALL_START: New call from $fu to $tu, Call-ID: $ci\n");
    
    # Create dialog for call tracking
    create_dialog();
    setflag(4);  # dialog flag
    
    # Extract call information
    $var(caller) = $fU;
    $var(called) = $tU;
    $var(call_id) = $ci;
    $var(from_tag) = $ft;
    
    # Store caller in dialog profile
    set_dlg_profile("caller", "$var(caller)");
    
    # Notify AI backend about new call via gRPC
    route(NOTIFY_AI_BACKEND);
    
    # Forward to AI Voice Connector
    $ru = "sip:" + $var(called) + "@" + AI_BACKEND_HOST + ":" + AI_BACKEND_PORT;
    
    # Set timeout for AI processing
    $avp(timeout) = 300;  # 5 minutes
    
    # Route the call
    route(RELAY);
}

# AI Call End Route  
route[AI_CALL_END] {
    xlog("L_INFO", "AI_CALL_END: Call ended, Call-ID: $ci\n");
    
    # Get dialog variables
    $var(caller) = $fU;
    $var(call_id) = $ci;
    
    # Notify AI backend about call end
    route(NOTIFY_AI_BACKEND_END);
    
    # Clean up dialog profile
    unset_dlg_profile("caller", "$var(caller)");
}

# Notify AI Backend via Event System
route[NOTIFY_AI_BACKEND] {
    # Raise event for new call
    raise_event("AI_CALL_START", $ci, 
                "caller", $fU,
                "called", $tU, 
                "from_tag", $ft,
                "to_tag", $tt);
                
    xlog("L_INFO", "Event raised: AI_CALL_START for Call-ID: $ci\n");
}

# Notify AI Backend about call end
route[NOTIFY_AI_BACKEND_END] {
    # Raise event for call end
    raise_event("AI_CALL_END", $ci,
                "caller", $fU,
                "reason", "normal");
                
    xlog("L_INFO", "Event raised: AI_CALL_END for Call-ID: $ci\n");
}

# Registrar route
route[REGISTRAR] {
    if (!is_method("REGISTER")) {
        return;
    }
    
    xlog("L_INFO", "REGISTER request from $fu\n");
    
    # Simple registration (no authentication for now)
    if (!save("location")) {
        sl_reply_error();
    }
}

# Relay route  
route[RELAY] {
    if (is_method("INVITE")) {
        t_on_failure("FAIL_ROUTE");
        t_on_branch("BRANCH_ROUTE");
    }
    
    if (!t_relay()) {
        sl_reply_error();
    }
}

# Branch route - called for each branch
branch_route[BRANCH_ROUTE] {
    xlog("L_INFO", "BRANCH_ROUTE: Forwarding to $ru\n");
}

# Failure route - called on failure
failure_route[FAIL_ROUTE] {
    if (t_was_cancelled()) {
        exit;
    }
    
    # Log failure
    xlog("L_WARN", "Call failed: $T_reply_code $T_reply_reason\n");
    
    # Notify AI backend about failure
    raise_event("AI_CALL_FAILED", $ci,
                "code", $T_reply_code,
                "reason", $T_reply_reason);
}

# Local route - called for locally generated requests
local_route {
    if (is_method("BYE") && $du) {
        xlog("L_INFO", "Local BYE generated\n");
    }
}

####### Event Routes #######

# Event route for AI_CALL_START
event_route[E_AI_CALL_START] {
    xlog("L_INFO", "Event handler: AI_CALL_START - $param(call_id)\n");
    
    # Send event to AI backend via datagram
    $var(event_data) = '{"event": "call_start", "call_id": "' + $param(call_id) + 
                       '", "caller": "' + $param(caller) + 
                       '", "called": "' + $param(called) + '"}';
                       
    send_event_datagram("udp:" + AI_BACKEND_HOST + ":8091", $var(event_data));
}

# Event route for AI_CALL_END
event_route[E_AI_CALL_END] {
    xlog("L_INFO", "Event handler: AI_CALL_END - $param(call_id)\n");
    
    # Send event to AI backend via datagram
    $var(event_data) = '{"event": "call_end", "call_id": "' + $param(call_id) + 
                       '", "caller": "' + $param(caller) + 
                       '", "reason": "' + $param(reason) + '"}';
                       
    send_event_datagram("udp:" + AI_BACKEND_HOST + ":8091", $var(event_data));
}

# Event route for AI_CALL_FAILED
event_route[E_AI_CALL_FAILED] {
    xlog("L_INFO", "Event handler: AI_CALL_FAILED - $param(call_id)\n");
    
    # Send event to AI backend via datagram
    $var(event_data) = '{"event": "call_failed", "call_id": "' + $param(call_id) + 
                       '", "code": "' + $param(code) + 
                       '", "reason": "' + $param(reason) + '"}';
                       
    send_event_datagram("udp:" + AI_BACKEND_HOST + ":8091", $var(event_data));
}