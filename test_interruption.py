#!/usr/bin/env python3
"""
Interruption (Barge-in) Test Suite
MinWordsInterruptionStrategy ve VolumeBasedInterruptionStrategy testleri
"""

import sys
import os
import asyncio
import numpy as np
from pathlib import Path
import time

# Python path setup
current_dir = Path(__file__).parent
src_path = current_dir / "src"
pipecat_src_path = current_dir / "pipecat" / "src"

if str(src_path) not in sys.path:
    sys.path.insert(0, str(src_path))
if str(pipecat_src_path) not in sys.path:
    sys.path.insert(0, str(pipecat_src_path))

# soxr compatibility stub
if not hasattr(sys.modules, 'soxr'):
    class SoxrStub:
        def resample(self, *args, **kwargs):
            return np.array([])
    sys.modules['soxr'] = SoxrStub()

import structlog
from pipeline.interruption import (
    MinWordsInterruptionStrategy, 
    VolumeBasedInterruptionStrategy, 
    InterruptionManager
)

# Setup logging
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="ISO"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()

async def test_min_words_strategy():
    """MinWordsInterruptionStrategy testi"""
    print("ğŸ”§ Testing MinWordsInterruptionStrategy...")
    
    # Test 1: 2 kelime threshold
    print("\nğŸ“ Test 1: 2 kelime threshold")
    strategy = MinWordsInterruptionStrategy(min_words=2)
    
    # Ä°lk kelime
    await strategy.append_text("Merhaba")
    should_interrupt = await strategy.should_interrupt()
    print(f"   1 kelime: {should_interrupt} (beklenen: False)")
    success1 = should_interrupt == False
    
    # Ä°kinci kelime
    await strategy.append_text("nasÄ±lsÄ±n")
    should_interrupt = await strategy.should_interrupt()
    print(f"   2 kelime: {should_interrupt} (beklenen: True)")
    success2 = should_interrupt == True
    
    # Reset test
    await strategy.reset()
    should_interrupt = await strategy.should_interrupt()
    print(f"   Reset sonrasÄ±: {should_interrupt} (beklenen: False)")
    success3 = should_interrupt == False
    
    # Test 2: TÃ¼rkÃ§e cÃ¼mle testi
    print("\nğŸ“ Test 2: TÃ¼rkÃ§e cÃ¼mle testi")
    await strategy.append_text("Dur")  # 1 kelime
    should_interrupt_1 = await strategy.should_interrupt()
    
    await strategy.append_text("artÄ±k")  # 2 kelime
    should_interrupt_2 = await strategy.should_interrupt()
    
    await strategy.append_text("konuÅŸmayÄ±")  # 3 kelime
    should_interrupt_3 = await strategy.should_interrupt()
    
    print(f"   'Dur': {should_interrupt_1} (False)")
    print(f"   'Dur artÄ±k': {should_interrupt_2} (True)")
    print(f"   'Dur artÄ±k konuÅŸmayÄ±': {should_interrupt_3} (True)")
    
    success4 = not should_interrupt_1 and should_interrupt_2 and should_interrupt_3
    
    return success1 and success2 and success3 and success4

async def test_volume_strategy():
    """VolumeBasedInterruptionStrategy testi"""
    print("\nğŸ”Š Testing VolumeBasedInterruptionStrategy...")
    
    strategy = VolumeBasedInterruptionStrategy(
        volume_threshold=0.5, 
        min_duration_ms=200
    )
    
    # Test 1: DÃ¼ÅŸÃ¼k ses seviyesi
    print("\nğŸ“ Test 1: DÃ¼ÅŸÃ¼k ses seviyesi")
    low_volume_audio = (np.random.randint(-1000, 1000, 1600, dtype=np.int16)).tobytes()
    await strategy.append_audio(low_volume_audio, 16000)
    should_interrupt = await strategy.should_interrupt()
    print(f"   DÃ¼ÅŸÃ¼k ses: {should_interrupt} (beklenen: False)")
    print(f"   Current volume: {strategy._current_volume}")
    success1 = should_interrupt == False
    
    # Test 2: YÃ¼ksek ses seviyesi - sÃ¼rekli gÃ¶nder
    print("\nğŸ“ Test 2: YÃ¼ksek ses seviyesi (sÃ¼rekli)")
    await strategy.reset()
    
    # Ã‡ok yÃ¼ksek ses oluÅŸtur
    high_volume_audio = (np.full(1600, 30000, dtype=np.int16)).tobytes()
    
    # Ä°lk chunk - yÃ¼ksek ses baÅŸlat
    await strategy.append_audio(high_volume_audio, 16000)
    should_interrupt_1 = await strategy.should_interrupt()
    print(f"   YÃ¼ksek ses (0ms): {should_interrupt_1} (beklenen: False)")
    print(f"   Current volume: {strategy._current_volume}, threshold: {strategy._volume_threshold}")
    print(f"   High volume start: {strategy._high_volume_start}")
    
    # 100ms bekle ve devam et
    await asyncio.sleep(0.1)
    await strategy.append_audio(high_volume_audio, 16000)
    should_interrupt_2 = await strategy.should_interrupt()
    print(f"   YÃ¼ksek ses (100ms): {should_interrupt_2} (beklenen: False)")
    print(f"   Current volume: {strategy._current_volume}")
    print(f"   High volume start: {strategy._high_volume_start}")
    
    # 150ms daha bekle (toplam 250ms)
    await asyncio.sleep(0.15)
    await strategy.append_audio(high_volume_audio, 16000)
    should_interrupt_3 = await strategy.should_interrupt()
    print(f"   YÃ¼ksek ses (250ms): {should_interrupt_3} (beklenen: True)")
    print(f"   Current volume: {strategy._current_volume}")
    print(f"   High volume start: {strategy._high_volume_start}")
    
    # Debug: Duration hesaplama
    if strategy._high_volume_start:
        current_time = time.time() * 1000
        duration = current_time - strategy._high_volume_start
        print(f"   Duration: {duration}ms, min required: {strategy._min_duration_ms}ms")
    
    success2 = not should_interrupt_1 and not should_interrupt_2 and should_interrupt_3
    
    # Test 3: Reset sonrasÄ±
    print("\nğŸ“ Test 3: Reset sonrasÄ±")
    await strategy.reset()
    should_interrupt_reset = await strategy.should_interrupt()
    print(f"   Reset sonrasÄ±: {should_interrupt_reset} (beklenen: False)")
    print(f"   Current volume after reset: {strategy._current_volume}")
    success3 = should_interrupt_reset == False
    
    return success1 and success2 and success3

async def test_interruption_manager():
    """InterruptionManager testi"""
    print("\nğŸ›ï¸ Testing InterruptionManager...")
    
    # Multiple strategies ile manager oluÅŸtur
    strategies = [
        MinWordsInterruptionStrategy(min_words=2),
        VolumeBasedInterruptionStrategy(volume_threshold=0.4, min_duration_ms=300)
    ]
    
    manager = InterruptionManager(strategies=strategies)
    
    # Test 1: Initial state
    print("\nğŸ“ Test 1: Initial state")
    status = manager.get_status()
    print(f"   Initial status: {status}")
    success1 = not status["bot_speaking"] and not status["user_speaking"]
    
    # Test 2: Bot speaking, user not speaking
    print("\nğŸ“ Test 2: Bot speaking, user not speaking")
    await manager.set_bot_speaking(True)
    await manager.set_user_speaking(False)
    allowed = manager.is_interruption_allowed()
    print(f"   Interruption allowed: {allowed} (beklenen: False)")
    success2 = allowed == False
    
    # Test 3: Both speaking - interruption allowed
    print("\nğŸ“ Test 3: Both speaking")
    await manager.set_user_speaking(True)
    allowed = manager.is_interruption_allowed()
    print(f"   Interruption allowed: {allowed} (beklenen: True)")
    success3 = allowed == True
    
    # Test 4: Text-based interruption
    print("\nğŸ“ Test 4: Text-based interruption")
    await manager.append_user_text("Dur")  # 1 kelime
    interrupted_1 = await manager.check_interruption()
    
    await manager.append_user_text("artÄ±k")  # 2 kelime
    interrupted_2 = await manager.check_interruption()
    
    print(f"   1 kelime sonrasÄ±: {interrupted_1} (False)")
    print(f"   2 kelime sonrasÄ±: {interrupted_2} (True)")
    success4 = not interrupted_1 and interrupted_2
    
    # Test 5: Reset after interruption - manager'Ä±n trigger_interruption Ã§aÄŸrÄ±sÄ± bot_speaking'i False yapar
    print("\nğŸ“ Test 5: Reset after interruption")
    status_after = manager.get_status()
    print(f"   Status after interruption: {status_after}")
    # trigger_interruption Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda bot_speaking False olur ve interruption_active sÄ±fÄ±rlanÄ±r
    success5 = not status_after["bot_speaking"]  # Bot artÄ±k konuÅŸmuyor
    
    return success1 and success2 and success3 and success4 and success5

async def test_conversation_scenario():
    """GerÃ§ek konuÅŸma senaryosu testi"""
    print("\nğŸ­ Testing Real Conversation Scenario...")
    
    manager = InterruptionManager([
        MinWordsInterruptionStrategy(min_words=2)
    ])
    
    # Senaryo: Bot konuÅŸuyor, kullanÄ±cÄ± araya giriyor
    print("\nğŸ“ Scenario: Bot speaking, user interrupts")
    
    # 1. Bot konuÅŸmaya baÅŸlar
    await manager.set_bot_speaking(True)
    print("   ğŸ¤– Bot started speaking")
    
    # 2. KullanÄ±cÄ± konuÅŸmaya baÅŸlar (araya girer)
    await manager.set_user_speaking(True)
    print("   ğŸ‘¤ User started speaking")
    
    # 3. KullanÄ±cÄ± ilk kelimeyi sÃ¶yler
    await manager.append_user_text("Dur")
    interrupted_1 = await manager.check_interruption()
    print(f"   ğŸ‘¤ 'Dur': Interrupted = {interrupted_1}")
    
    # 4. KullanÄ±cÄ± ikinci kelimeyi sÃ¶yler
    await manager.append_user_text("lÃ¼tfen")
    interrupted_2 = await manager.check_interruption()
    print(f"   ğŸ‘¤ 'Dur lÃ¼tfen': Interrupted = {interrupted_2}")
    
    # 5. Status kontrolÃ¼
    final_status = manager.get_status()
    print(f"   ğŸ“Š Final status: {final_status}")
    
    # BaÅŸarÄ± koÅŸullarÄ±:
    # - Ä°lk kelimede kesmesin (False)
    # - Ä°kinci kelimede kessin (True)
    # - Son durumda bot konuÅŸmuyor olmalÄ± (trigger_interruption bot'u durdurur)
    success = (
        not interrupted_1 and  # Ä°lk kelimede kesmesin
        interrupted_2 and      # Ä°kinci kelimede kessin
        not final_status["bot_speaking"]  # Bot artÄ±k konuÅŸmuyor
    )
    
    if success:
        print("   âœ… Conversation scenario PASSED!")
        print("      - Bot was speaking")
        print("      - User said 2 words")
        print("      - Interruption triggered correctly")
        print("      - Bot stopped speaking after interruption")
    else:
        print("   âŒ Conversation scenario FAILED!")
        print(f"      - interrupted_1: {interrupted_1} (should be False)")
        print(f"      - interrupted_2: {interrupted_2} (should be True)")
        print(f"      - bot_speaking: {final_status['bot_speaking']} (should be False)")
    
    return success

async def main():
    """Ana test fonksiyonu"""
    print("ğŸš€ Interruption (Barge-in) Test Suite")
    print("=" * 50)
    
    # Test 1: MinWordsInterruptionStrategy
    success1 = await test_min_words_strategy()
    
    # Test 2: VolumeBasedInterruptionStrategy
    success2 = await test_volume_strategy()
    
    # Test 3: InterruptionManager
    success3 = await test_interruption_manager()
    
    # Test 4: Conversation Scenario
    success4 = await test_conversation_scenario()
    
    print("\n" + "=" * 50)
    print("ğŸ“‹ Test Results Summary:")
    print(f"   ğŸ”¤ MinWords Strategy: {'âœ… PASS' if success1 else 'âŒ FAIL'}")
    print(f"   ğŸ”Š Volume Strategy: {'âœ… PASS' if success2 else 'âŒ FAIL'}")
    print(f"   ğŸ›ï¸ Interruption Manager: {'âœ… PASS' if success3 else 'âŒ FAIL'}")
    print(f"   ğŸ­ Conversation Scenario: {'âœ… PASS' if success4 else 'âŒ FAIL'}")
    
    all_passed = success1 and success2 and success3 and success4
    print(f"\nğŸ¯ Overall Result: {'âœ… ALL TESTS PASSED' if all_passed else 'âŒ SOME TESTS FAILED'}")
    
    if all_passed:
        print("\nğŸ‰ Barge-in Interruption System is working perfectly!")
        print("   âœ… MinWords strategy works (2+ words trigger interruption)")
        print("   âœ… Volume strategy works (loud audio triggers interruption)")
        print("   âœ… Manager coordinates multiple strategies")
        print("   âœ… Real conversation scenarios handled correctly")
        print("   âœ… Ready for integration with OpenSIPS Voice Connector")
    else:
        print("\nâš ï¸ Please check the failed tests and fix issues")
    
    return 0 if all_passed else 1

if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code) 