#
# OpenSIPS Configuration for IVR Testing with Outbound Call Support
# Supports both inbound voice assistant calls and outbound IVR testing
#

####### Global Parameters #########

# Enable logging
log_level=3
log_stderror=no
log_facility=LOG_LOCAL0

# Ports and interfaces
port=5060
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060

# Server header and user agent
server_header="Server: OpenSIPS-IVR-Tester (2.4.9)"
user_agent_header="User-Agent: OpenSIPS-IVR-Tester"

####### Modules Section ########

# Core modules
loadmodule "signaling.so"
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "acc.so"
loadmodule "proto_udp.so"
loadmodule "proto_tcp.so"

# Dialog module for call tracking
loadmodule "dialog.so"
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "default_timeout", 21600)  # 6 hours

# MI (Management Interface) module for call control
loadmodule "mi_fifo.so"
loadmodule "mi_http.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_http", "port", 8080)

# RTP Proxy module for media handling
loadmodule "rtpproxy.so"
modparam("rtpproxy", "rtpproxy_sock", "udp:localhost:7890")

# Event notification for call tracking
loadmodule "event_route.so"
loadmodule "httpd.so"
modparam("httpd", "port", 8090)

# UAC module for outbound calls
loadmodule "uac.so"
modparam("uac", "credential", "test:ivr_test_domain:test_password")

# B2B module for advanced call control
loadmodule "b2b_entities.so"
loadmodule "b2b_logic.so"

####### Routing Logic ########

# Main routing block
route{
    # Initial sanity checks
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if (msg:len >=  2048 ) {
        sl_send_reply("513", "Message too big");
        exit;
    }

    # Record routing for dialog-creating requests
    if (has_totag()) {
        # Sequential request
        if (loose_route()) {
            xlog("L_INFO", "Sequential request routed: $rm from $si\n");
            
            # Handle RTP proxy for in-dialog requests
            if (is_method("INVITE|UPDATE|ACK|PRACK|REFER")) {
                rtpproxy_offer();
            } else if (is_method("BYE|CANCEL")) {
                rtpproxy_unforce();
            }
            
            # Route to destination
            route(RELAY);
            exit;
        } else {
            if (is_method("ACK")) {
                if (t_check_trans()) {
                    t_relay();
                    exit;
                } else {
                    exit;
                }
            }
            sl_send_reply("404","Not here");
            exit;
        }
    }

    # Record-Route header for dialog-creating requests
    if (is_method("INVITE|SUBSCRIBE"))
        record_route();

    # Account for requests
    if (is_method("INVITE")) {
        setflag(1); # Flag for accounting
    }

    # Handle different request types
    if (is_method("REGISTER")) {
        route(REGISTER);
        exit;
    }

    if (is_method("INVITE")) {
        route(INVITE);
        exit;
    }

    if (is_method("BYE|CANCEL")) {
        route(BYE_CANCEL);
        exit;
    }

    # Default handler
    route(RELAY);
}

# INVITE handling route
route[INVITE] {
    xlog("L_INFO", "Processing INVITE: $rm from $si to $ru\n");
    
    # Create dialog for call tracking
    create_dialog();
    
    # Determine if this is inbound (for voice assistant) or outbound (for IVR testing)
    if ($si == "127.0.0.1" || $si == "localhost") {
        # This is an outbound call initiated by our test system
        xlog("L_INFO", "Outbound IVR test call detected: $ci\n");
        route(OUTBOUND_CALL);
    } else {
        # This is an inbound call for voice assistant
        xlog("L_INFO", "Inbound voice assistant call detected: $ci\n");
        route(INBOUND_CALL);
    }
}

# Outbound call routing (for IVR testing)
route[OUTBOUND_CALL] {
    xlog("L_INFO", "Routing outbound call: $ci to $rU\n");
    
    # Set outbound proxy or direct routing
    # TODO: Configure your SIP trunk/provider here
    $du = "sip:" + $rU + "@sip.example.com";  # Replace with actual SIP provider
    
    # Setup RTP proxy
    rtpproxy_offer("co");
    
    # Add Call-ID tracking
    $avp(call_direction) = "outbound";
    
    # Send notification about call attempt
    $var(event_data) = '{"event": "trying", "callid": "' + $ci + '", "direction": "outbound", "target": "' + $rU + '"}';
    
    # Forward the call
    t_on_reply("OUTBOUND_REPLY");
    t_on_failure("OUTBOUND_FAILURE");
    
    if (!t_relay()) {
        sl_reply_error();
        exit;
    }
}

# Inbound call routing (for voice assistant)
route[INBOUND_CALL] {
    xlog("L_INFO", "Routing inbound call: $ci from $fU\n");
    
    # Route to local voice assistant application
    $du = "sip:127.0.0.1:8089";  # Voice assistant SIP backend
    
    # Setup RTP proxy
    rtpproxy_offer("co");
    
    # Add Call-ID tracking
    $avp(call_direction) = "inbound";
    
    # Send notification about incoming call
    $var(event_data) = '{"event": "incoming", "callid": "' + $ci + '", "direction": "inbound", "from": "' + $fU + '"}';
    
    # Forward the call
    t_on_reply("INBOUND_REPLY");
    t_on_failure("INBOUND_FAILURE");
    
    if (!t_relay()) {
        sl_reply_error();
        exit;
    }
}

# Outbound call reply handling
onreply_route[OUTBOUND_REPLY] {
    xlog("L_INFO", "Outbound call reply: $rs $rr for $ci\n");
    
    if (status =~ "[12][0-9][0-9]") {
        rtpproxy_answer("co");
        
        if (status =~ "18[0-9]") {
            # Ringing
            $var(event_data) = '{"event": "ringing", "callid": "' + $ci + '", "status": ' + $rs + '}';
        } else if (status =~ "200") {
            # Connected
            $var(event_data) = '{"event": "answered", "callid": "' + $ci + '", "status": ' + $rs + '}';
        }
    }
}

# Inbound call reply handling  
onreply_route[INBOUND_REPLY] {
    xlog("L_INFO", "Inbound call reply: $rs $rr for $ci\n");
    
    if (status =~ "[12][0-9][0-9]") {
        rtpproxy_answer("co");
    }
}

# Outbound call failure handling
failure_route[OUTBOUND_FAILURE] {
    xlog("L_INFO", "Outbound call failed: $ci with status $T_reply_code\n");
    
    rtpproxy_unforce();
    
    $var(event_data) = '{"event": "failed", "callid": "' + $ci + '", "reason": "' + $T_reply_code + ' ' + $T_reply_reason + '"}';
    
    if (t_was_cancelled()) {
        xlog("L_INFO", "Outbound call was cancelled: $ci\n");
        exit;
    }
    
    # Could implement failover logic here
}

# Inbound call failure handling
failure_route[INBOUND_FAILURE] {
    xlog("L_INFO", "Inbound call failed: $ci with status $T_reply_code\n");
    
    rtpproxy_unforce();
    
    if (t_was_cancelled()) {
        exit;
    }
}

# BYE/CANCEL handling
route[BYE_CANCEL] {
    xlog("L_INFO", "Processing $rm for call $ci\n");
    
    # Cleanup RTP proxy
    rtpproxy_unforce();
    
    # Send call ended notification
    $var(event_data) = '{"event": "ended", "callid": "' + $ci + '", "method": "' + $rm + '"}';
    
    route(RELAY);
}

# Registration handling
route[REGISTER] {
    xlog("L_INFO", "Processing REGISTER from $si\n");
    
    if (!save("location")) {
        sl_reply_error();
        exit;
    }
    
    exit;
}

# Generic relay route
route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
        exit;
    }
}

####### Event Handling ########

# Dialog events for call tracking
event_route[dialog:start] {
    xlog("L_INFO", "Dialog started: $DLG_callid\n");
}

event_route[dialog:end] {
    xlog("L_INFO", "Dialog ended: $DLG_callid\n");
    
    # Send call completed notification
    $var(event_data) = '{"event": "completed", "callid": "' + $DLG_callid + '"}';
}