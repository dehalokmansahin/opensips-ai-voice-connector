####### Global Parameters #########

log_level=3
stderror_enabled=yes
syslog_enabled=no

socket=udp:*:5060

####### Modules Section ########

#set module path
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules/"

loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "sipmsgops.so"
loadmodule "signaling.so"
loadmodule "cfgutils.so"
loadmodule "mi_fifo.so"
loadmodule "proto_tcp.so"
loadmodule "proto_udp.so"
loadmodule "sl.so"
loadmodule "mi_datagram.so"
loadmodule "b2b_entities.so"
loadmodule "event_datagram.so"
loadmodule "rtpproxy.so"
loadmodule "nathelper.so"
loadmodule "textops.so"
loadmodule "dialog.so"

modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")

modparam("tm", "fr_timeout", 2)
modparam("tm", "fr_inv_timeout", 3)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

# MI Datagram - OpenSIPS'in OAVC'den MI komutlarını dinlediği yer
# 127.0.0.1 yerine 0.0.0.0 kullanın ki diğer konteynerler erişebilsin
modparam("mi_datagram", "socket_name", "udp:0.0.0.0:8088")

# B2B entities parameters for AI Voice Connector
modparam("b2b_entities", "server_hsize", 13)
modparam("b2b_entities", "client_hsize", 13)
modparam("b2b_entities", "b2b_key_prefix", "B2B")

# RTP proxy setup - Use service name for Docker Compose
modparam("rtpproxy", "rtpproxy_sock", "udp:rtpproxy:35005")

# Dialog module setup
modparam("dialog", "enable_stats", 1)

# Event Datagram - subscribe to send events to OAVC (use service name)
startup_route {
    # Subscribe for events using OAVC socket
    subscribe_event("E_CALL_INIT", "udp:oavc:35010");
    subscribe_event("E_CALL_HANGUP", "udp:oavc:35010");
}

####### Routing Logic ########

# Main request routing
route {
	xlog("L_INFO", "Received $rm from $fu to $ru with Call-ID: $ci\n");

	if (has_totag()) {
		# Sequential request within a dialog
		if (loose_route()) {
			xlog("L_INFO", "Routing sequential request $rm for dialog $DLG_did\n");
			if (is_method("BYE")) {
				# Call hangup - notify OAVC
				xlog("L_INFO", "BYE received for dialog $DLG_did\n");
				$avp(attrs) = "call_id";
				$avp(vals) = $ci;
				$avp(attrs) = "dialog_id";
				$avp(vals) = $DLG_did;
				raise_event("E_CALL_HANGUP", $avp(attrs), $avp(vals));
				# Optional: Engage rtpproxy for BYE if needed (usually not)
			}
			# Handle other in-dialog requests like re-INVITE, INFO etc.
			# Potentially engage rtpproxy if SDP changes
			if (is_method("INVITE") && has_body("application/sdp")) {
				rtpproxy_offer("cor"); # Handle re-INVITE with SDP
			}
			route(relay);
		} else {
			# Could be CANCEL or ACK - handle appropriately
			if (is_method("CANCEL")) {
				# Handle CANCEL if necessary, especially with B2B
				xlog("L_WARN", "Received CANCEL for $ci\n");
			}
			send_reply(404, "Not here");
			exit;
		}
		exit;
	}

	# Initial request processing
	# Check for unwanted requests
	if (!is_method("INVITE")) {
		send_reply(405, "Method Not Allowed");
		exit;
	}

	# --- Initial INVITE Processing ---
	xlog("L_INFO", "Processing initial INVITE from $fu for $tu (Call-ID: $ci)\n");

	# Record route to stay in the path
	record_route();

	# Engage RTPProxy for the caller's SDP
	if (!rtpproxy_offer("cor")) {
		xlog("L_ERR", "Error engaging rtpproxy for offer\n");
		send_reply(500, "Internal Server Error - RTPProxy Offer");
		exit;
	}

	# Create dialog state
	if (!create_dialog("B")) { # Added 'B' flag for B2B compatibility if needed
		xlog("L_ERR", "Error creating dialog\n");
		send_reply(500, "Internal Server Error - Dialog Creation");
		exit;
	}

	# Initialize B2B session for OAVC (Removed invalid flags "RB")
    # $var(b2b_key) kullanımının doğru olduğundan emin olun, bazen $b2b_key kullanılır.
	if (!ua_session_server_init($var(b2b_key))) {
		xlog("L_ERR", "Error initializing B2B session\n");
		send_reply(500, "Internal Server Error - B2B Init");
		exit;
	}

	# Notify OAVC about new call
	$avp(attrs) = "call_id";
	$avp(vals) = $ci;
	$avp(attrs) = "b2b_key";
	$avp(vals) = $var(b2b_key); # $var(b2b_key) yerine $b2b_key olabilir mi? Kontrol edin.
	$avp(attrs) = "dialog_id";
	$avp(vals) = $DLG_did;
	$avp(attrs) = "caller";
	$avp(vals) = $fU + "@" + $fd;
	$avp(attrs) = "callee";
	$avp(vals) = $tU + "@" + $td;
	raise_event("E_CALL_INIT", $avp(attrs), $avp(vals));

	xlog("L_INFO", "Raised E_CALL_INIT for B2B key $var(b2b_key), dialog ID {$DLG_did}. Waiting for OAVC action.\n");

	# --- IMPORTANT ---
	# At this point, OpenSIPS needs instructions from OAVC via MI.
	exit;

}

# Route for relaying requests within a dialog
route[relay] {
	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Reply handling route
onreply_route {
	xlog("L_INFO", "Received reply: $rs $rr for $cs Call-ID: $ci\n");

	# Engage rtpproxy for answers containing SDP
	if (has_body("application/sdp")) {
		if (!rtpproxy_answer("cor")) {
			xlog("L_ERR", "Error engaging rtpproxy for answer\n");
			# Potentially send error response or just log
		}
	}

	# Check if this reply belongs to a B2B session and handle if needed
	# (Specific B2B reply handling might go in a dedicated onreply_route[b2b_callback])

	# Forward the reply (TM module usually handles this statefully)
	# if (!t_relay()) {
	# 	xlog("L_ERR", "Failed to relay reply\n");
	# }
	exit;
}

# B2B callback function - can be used for specific B2B reply logic
onreply_route[b2b_callback] {
	xlog("L_INFO", "B2B callback reply: $rs $rm");
	# Add specific B2B reply processing here if needed
	if (has_body("application/sdp")) {
		if (!rtpproxy_answer("cor")) {
			xlog("L_ERR", "rtpproxy_answer failed in b2b_callback\n");
		}
	}
	exit;
}

# B2B logic function - typically triggered by MI commands from OAVC
route[b2b_logic] {
	# This route is usually empty in the main config
	# and logic is handled via MI commands like b2b_logic_request
	xlog("L_INFO", "Executing B2B logic route (likely triggered by MI)");
}