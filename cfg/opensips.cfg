####### Global Parameters #########

# Enhanced Logging
log_level=3
stderror_enabled=yes
syslog_enabled=yes
syslog_facility=LOG_LOCAL0
xlog_level=3

memlog=5
memdump=5
execmsgthreshold=50

# Enhanced Socket Configuration
socket=udp:0.0.0.0:5060   # Main SIP port
socket=tcp:0.0.0.0:5060   # SIP over TCP  
socket=udp:0.0.0.0:8080   # Additional SIP port
# OAVC SIP Interface - accepts calls (dynamic - listens on all interfaces)
# socket=udp:0.0.0.0:8089

# SIP Protocol Enhancements
auto_aliases=no
sip_warning=no
server_header="Server: OpenSIPS AI Voice Connector"
user_agent_header="User-Agent: OpenSIPS-OAVC"

####### Modules Section ########

# Set module path
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules/"

# Core modules
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "sipmsgops.so"
loadmodule "signaling.so"
loadmodule "cfgutils.so"
loadmodule "mi_fifo.so"
loadmodule "proto_tcp.so"
loadmodule "proto_udp.so"
loadmodule "sl.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"

loadmodule "mi_datagram.so"
loadmodule "event_datagram.so"
# loadmodule "b2b_entities.so"    # Not available in this image

# Dialog and Statistics modules
loadmodule "dialog.so"
# loadmodule "statistics.so"      # Not available in this image

# Authentication and Authorization (if needed)
# loadmodule "auth.so"
# loadmodule "auth_db.so"

####### Module Parameters ########

# Transaction Module
modparam("tm", "fr_timeout", 10)        # Final response timeout - reasonable for retransmissions
modparam("tm", "fr_inv_timeout", 32)    # INVITE timeout - standard SIP value

# TM Enhanced Configuration for debugging and reliability
modparam("tm", "restart_fr_on_each_reply", 1)    # Keep default - restart timer on each reply
modparam("tm", "onreply_avp_mode", 1)           # Optimize reply handling  

modparam("rr", "append_fromtag", 1)

# MI FIFO Interface
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)
modparam("mi_fifo", "reply_dir", "/tmp/")

modparam("mi_datagram", "socket_name", "udp:0.0.0.0:8087")
modparam("mi_datagram", "children_count", 2)

# B2B Entities Module (commented out - module not available)
# modparam("b2b_entities", "server_address", "sip:ai-voice-connector@0.0.0.0:5060")
# modparam("b2b_entities", "b2b_key_prefix", "B2B_")

# Dialog Module
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "default_timeout", 21600)  # 6 hours
modparam("dialog", "db_mode", 0)              # No database persistence

# Max Forward Module
modparam("maxfwd", "max_limit", 16)

# Event Datagram Module - OAVC event notifications (commented out - module not available)
# modparam("event_datagram", "address", "udp:opensips-ai-voice-connector:8090")
# modparam("event_datagram", "children_count", 2)

####### Custom Variables #########

# OAVC Integration variables will be defined in routing logic
# Variables: oavc_host, oavc_port, ai_processing_timeout

####### Routing Logic ########

# Main SIP request routing
route {
    
    # ============ Sanity Checks ============
    
    # Check max forwards
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }
    
    # Record route for dialog forming requests with container IP
    if (is_method("INVITE|SUBSCRIBE")) {
        # Use Docker container IP for Record-Route (fix 0.0.0.0 issue)
        # This allows subsequent requests to be routed correctly
        record_route_preset("172.18.0.4:5060");
        xlog("L_INFO", "[$ci] üéØ Record-Route set with Docker container IP: 172.18.0.4\n");
    }
    
    # Handle retransmissions
    if (t_check_trans()) {
        t_relay();
        exit;
    }
    
    # ============ Request Filtering ============
    
    # Only allow INVITE, ACK, BYE, CANCEL for this AI voice connector
    if (!is_method("INVITE|ACK|BYE|CANCEL|OPTIONS")) {
        xlog("L_WARN", "[$ci] Method $rm not supported from $si:$sp\n");
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }
    
    # Handle OPTIONS (keepalive/health check)
    if (is_method("OPTIONS")) {
        xlog("L_INFO", "[$ci] OPTIONS request from $si:$sp\n");
        sl_send_reply(200, "OK");
        exit;
    }
    
    # ============ Dialog Handling ============
    
    # CRITICAL FIX: Handle ACK messages BEFORE has_totag() check
    # ACK messages can be both initial (for 200 OK) and in-dialog
    if (is_method("ACK")) {
        xlog("L_INFO", "[$ci] üéØ Processing ACK message from $si:$sp\n");
        
        # Check if this is an in-dialog ACK (has to-tag)
        if (has_totag()) {
            xlog("L_INFO", "[$ci] üìû In-dialog ACK processing\n");
            if (loose_route()) {
                xlog("L_INFO", "[$ci] ‚úÖ ACK routed via loose_route\n");
                t_relay();
            } else {
                xlog("L_WARN", "[$ci] ‚ö†Ô∏è loose_route failed for in-dialog ACK\n");
                # Try direct routing to OAVC
                $ru = "sip:" + $rU + "@ai-voice-backend:8089";
                forward();
            }
        } else {
            xlog("L_INFO", "[$ci] üìû Initial ACK processing - routing to OAVC\n");
            # Initial ACK for 200 OK response - route directly to OAVC
            $ru = "sip:" + $rU + "@ai-voice-backend:8089";
            # Use forward() for ACK (not t_relay as ACK is not transaction forming)
            forward();
        }
        exit;
    }
    
    # In-dialog requests (except ACK which is handled above)
    if (has_totag()) {
        
        # Handle in-dialog BYE and CANCEL  
        if (is_method("BYE|CANCEL")) {
            xlog("L_INFO", "[$ci] In-dialog $rm from $si:$sp\n");
            
            # Forward to appropriate destination
            if (loose_route()) {
                t_on_failure("1");
                t_relay();
                exit;
            } else {
                xlog("L_WARN", "[$ci] Loose route failed for in-dialog $rm\n");
                sl_send_reply(481, "Call/Transaction Does Not Exist");
                exit;
            }
        }
        
        # Other in-dialog requests
        if (loose_route()) {
            t_on_reply("1");
            t_on_failure("1");
            t_relay();
            exit;
        } else {
            sl_send_reply(481, "Call/Transaction Does Not Exist");
            exit;
        }
    }
    
    # ============ Initial INVITE Processing ============
    
    # Only process initial INVITEs (ACK is handled above)
    if (!is_method("INVITE")) {
        xlog("L_WARN", "[$ci] Unexpected initial request: $rm from $si:$sp (ACK should be handled above)\n");
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }
    
    # Validate INVITE
    if (!has_body("application/sdp")) {
        xlog("L_WARN", "[$ci] INVITE without SDP from $si:$sp\n");
        sl_send_reply(400, "Bad Request - SDP Required");
        exit;
    }
    
    # ============ Simplified AI Voice Processing ============
    
    # Define OAVC variables
    $var(oavc_host) = "opensips-ai-voice-connector";
    $var(oavc_port) = "8089";
    $var(ai_processing_timeout) = 60;
    
    # Log call initiation
    xlog("L_NOTICE", "[$ci] Starting AI Voice Call Processing\n");
    xlog("L_INFO", "[$ci] From: $fu, To: $tu, Contact: $ct\n");
    xlog("L_INFO", "[$ci] Routing to OAVC at $var(oavc_host):$var(oavc_port)\n");
    
    # Update Request-URI for OAVC routing
    $ru = "sip:" + $rU + "@" + $var(oavc_host) + ":" + $var(oavc_port);
    
    # Add custom headers for AI processing
    append_hf("X-AI-Processing: enabled\r\n");
    append_hf("X-Call-ID: $ci\r\n");
    
    # Set reply and failure routes
    t_on_reply("1");
    t_on_failure("1");
    
    # Forward to OAVC
    if (!t_relay()) {
        xlog("L_ERR", "[$ci] Failed to relay INVITE to OAVC\n");
        sl_send_reply(500, "Internal Server Error - Relay Failed");
        exit;
    }
     
    xlog("L_INFO", "[$ci] INVITE successfully relayed to OAVC\n");
    exit;
}

# ============ Reply Route ============
onreply_route[1] {
    
    # üö® DEBUG: Force log to see if reply route is called at all
    xlog("L_WARN", "[$ci] üî• REPLY ROUTE CALLED! Status: $rs from $si:$sp\n");
    
    xlog("L_INFO", "[$ci] üì® Reply received: $rs $rr from OAVC (source: $si:$sp)\n");
    
    # Handle specific reply codes
    if ($rs =~ "18[0-9]") {
        xlog("L_INFO", "[$ci] üìû Ringing/Session Progress: $rs\n");
        
        # Add AI processing indicator
        if (!search("X-AI-Status:")) {
            append_hf("X-AI-Status: processing\r\n");
        }
    }
    else if ($rs =~ "2[0-9][0-9]") {
        xlog("L_NOTICE", "[$ci] ‚úÖ Call established: $rs - Forwarding to client\n");
        
        # Add success headers
        append_hf("X-AI-Status: connected\r\n");
        append_hf("X-AI-Processing-Time: $Ts\r\n");
    }
    else if ($rs =~ "[4-6][0-9][0-9]") {
        xlog("L_WARN", "[$ci] ‚ùå Call failed: $rs $rr\n");
        
        # Add failure reason
        append_hf("X-AI-Status: failed\r\n");
        append_hf("X-AI-Error: $rr\r\n");
    }
    
    # üîß CRITICAL FIX: Forward the reply to client instead of dropping
    xlog("L_INFO", "[$ci] üì§ Forwarding reply $rs to client\n");
    # Don't use drop; - let the reply be forwarded to client
}

# ============ Failure Route ============
failure_route[1] {
    
    xlog("L_ERR", "[$ci] Transaction failed: $T_reply_code\n");
    
    # Handle specific failure scenarios
    if (t_check_status("408")) {
        xlog("L_ERR", "[$ci] Request timeout - AI processing took too long\n");
        send_reply(504, "AI Processing Timeout");
    }
    else if (t_check_status("503")) {
        xlog("L_ERR", "[$ci] Service unavailable - OAVC may be down\n");
        send_reply(503, "AI Service Temporarily Unavailable");
    }
    else if (t_check_status("500")) {
        xlog("L_ERR", "[$ci] Internal server error in AI processing\n");
        send_reply(500, "AI Processing Error");
    }
    else if (t_check_status("486|487|603")) {
        xlog("L_INFO", "[$ci] Call rejected/cancelled: $T_reply_code\n");
        # Forward the original response
    }
    else {
        xlog("L_WARN", "[$ci] Unhandled failure: $T_reply_code\n");
        send_reply(500, "Call Processing Failed");
    }
}